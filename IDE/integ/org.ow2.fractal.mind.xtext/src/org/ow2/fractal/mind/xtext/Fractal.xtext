grammar org.ow2.fractal.mind.xtext.Fractal with org.eclipse.xtext.common.Terminals //hidden(WS)
import  'http://org.ow2.fractal/mind/mind.ecore/1.0.0'

AdlDefinition : 
((imports+=ImportDefinition)*)
(definitionAnnotationsList=AnnotationsList)?
((architecturedefinition+=ArchitectureDefinition)*)
;

ImportDefinition :
'import'
importName=FullyQualifiedName 
('.*')? ';'
;

ArchitectureDefinition : 
ComponentTypeDefinition | 
PrimitiveComponentDefinition | 
CompositeComponentDefinition;

PrimitiveComponentDefinition : 
(abstract?='abstract')? 
'primitive'
name=FullyQualifiedName
(primitiveFormalArgumentsList=FormalArgumentsList)?
(primitiveReferencesList=PrimitiveReferencesList)?
(
	('{'(
			(primitiveElements+=AnnotationsList)?
			primitiveElements+=PrimitiveDefinitionElement
	)*'}')
	|
	(
		(primitiveElements+=AnnotationsList)?
		primitiveElements+=PrimitiveDefinitionElement
	)*
);

PrimitiveDefinitionElement :
(InterfaceDefinition
| AttributeDefinition
| DataDefinition
| ImplementationDefinition)
(';')?
;

ComponentTypeDefinition :
'type'
name=FullyQualifiedName
(typeReferencesList=TypeReferencesList)?
(

		(
		(typeElements+=AnnotationsList)?
		typeElements+=TypeDefinitionElement
		)*
		|
	('{'
		(
		(typeElements+=AnnotationsList)?
		typeElements+=TypeDefinitionElement
		)*
	'}') 
);

TypeReferencesList :
'extends' typeReferences+=TypeReferenceDefinition	(',' typeReferences+=TypeReferenceDefinition)*;

TypeReferenceDefinition :
referenceName = FullyQualifiedName
;


TypeDefinitionElement : 
InterfaceDefinition
(';')?;

CompositeComponentDefinition : 
'composite'
name=FullyQualifiedName
(templateSpecifiersList=TemplateSpecifiersList)?
(compositeFormalArgumentsList=FormalArgumentsList)?
(compositeReferencesList=CompositeReferencesList)?

(
	(
	'{' 
		(
			(compositeElements+=AnnotationsList)?
			compositeElements+=CompositeDefinitionElement
		)* 
	'}'
	)
	|
		(
		(compositeElements+=AnnotationsList)?
		compositeElements+=CompositeDefinitionElement
		)* 
)
;

TemplateSpecifiersList :
'<' 
(templateSpecifiers+=TemplateSpecifier 
( ',' templateSpecifiers+=TemplateSpecifier )*) 
'>';

FormalArgumentsList :
'('
	(formalArguments+=FormalArgument 
	( ',' formalArguments+=FormalArgument )*) 
')';

CompositeReferencesList :
'extends'  
compositeReferences+=CompositeReferenceDefinition	
(',' compositeReferences+=CompositeReferenceDefinition)*;

PrimitiveReferencesList :
'extends' 
primitiveReferences+=PrimitiveReferenceDefinition	
(',' primitiveReferences+=PrimitiveReferenceDefinition)*;

FormalArgument :
name=ID;

CompositeDefinitionElement :
(SubComponentDefinition 
| InterfaceDefinition 
| BindingDefinition)
(';')?
;

SubComponentDefinition :
'contains'
(
	CompositeSubComponent
	|
	CompositeAnonymousSubComponent
	|
	PrimitiveSubComponent
	|
	PrimitiveAnonymousSubComponent
	|
	TemplateSubComponent
)
;

CompositeReferenceDefinition :
referenceName = FullyQualifiedName
(
	"<"
	templatesList+=TemplateDefinition
	("," templatesList+=TemplateDefinition)*
	">"
)?
(
	"("
	argumentsList+=ArgumentDefinition 
	("," argumentsList+=ArgumentDefinition)* 
	")"
	
)?;


CompositeSubComponent : 
'composite'
compositeReferenceDefinition = CompositeReferenceDefinition
'as'
name=ID
;

CompositeAnonymousSubComponent :
'composite'
(compositeReferenceDefinition = CompositeReferenceDefinition)?
'as'
name=ID
'{'
	( 
		(		
			(compositeElements+=AnnotationsList)?
			compositeElements+=CompositeDefinitionElement
		)
	)*
'}'
;


PrimitiveReferenceDefinition :
referenceName = FullyQualifiedName 
(
	"(" 
	argumentsList+=ArgumentDefinition 
	("," argumentsList+=ArgumentDefinition)* 
	")"
)?
;

TemplateDefinition :
(templateName=ID "=")? 
(
	(templateValue=FullyQualifiedName) 
	| 
	"?"
);

TemplateSubComponent :
templateReferenceDefinition = [TemplateSpecifier]
'as'
name = ID
;

PrimitiveSubComponent :
'primitive'
primitiveReferenceDefinition=PrimitiveReferenceDefinition
'as' name=ID
;

PrimitiveAnonymousSubComponent :
'primitive'
(primitiveReferenceDefinition=PrimitiveReferenceDefinition)?
'as' name=ID
'{'
	( 
		(
			(primitiveElements+=AnnotationsList)?
			primitiveElements+=PrimitiveDefinitionElement
		)
	)*
'}'
;

AttributeDefinition :
'attribute' 
(type=AttributeType)?
attributeName = ID
('=' value=Value)?
;

ArgumentDefinition :
(argumentName = ID "=")? 
argumentValue=Value;

InterfaceDefinition :
role=Role
(signature=FullyQualifiedName)? 
'as' 
name=ID 
(
	collection?='[' 
	(collectionsize=INT)? 
	collection?=']'
)?
(contingency=Contingency)?
;

BindingDefinition : 
(
	'binds'
	(
		'this'
		|
		interfaceSourceParent=[ArchitectureDefinition]
	) 
	'.' 
	interfaceSource=[InterfaceDefinition]
	('['interfaceSourceIndex=INT']')?
	'to'
	(
		'this'
		|
		interfaceTargetParent=[ArchitectureDefinition]
	) 
	'.'
	interfaceTarget=[InterfaceDefinition] 
	('[' interfaceTargetIndex=INT ']')?)
;

DataDefinition :
(
	('data'
		(
			(fileC=FileC) 
			| 
			('{{' inlineCcode=InlineCodeC '}}')
		)
	)
	| 
	('nodata')
) 
;

ImplementationDefinition :
'source' 
(
	(fileC=FileC) 
	| 
	('{{'inlineCcode=InlineCodeC'}}')
) 
;

TemplateSpecifier :
name=ID 
'conformsto'
componentTypeName=FullyQualifiedName;

FullyQualifiedName : ID('.'ID)*;

FileC :
(directory = Path)? 
fileName=Filename
;

Filename : 
ID'.'ID
;

InlineCodeC :
codeC = CodeC
;

AnnotationsList :
annotations+=Annotation 
( annotations+=Annotation )*
;

Annotation :
'@' name=AnnotationType
( 
	"("annotationElements+=AnnotationElement
	(',' annotationElements+=AnnotationElement)* ")"
)?;

AnnotationElement :
 (elementName=ID  '=')? elementValue=ElementValue
;

ElementValue :
ConstantValue |
Annotation |
ElementValueArrayInitializer;

ConstantValue :
value = ConstantFormat;

ConstantFormat :
INT | STRING;

ElementValueArrayInitializer :
"{" 
values+=ElementValue
("," values+=ElementValue)* 
"}"; 

//Terminal rule à faire
CodeC :
(ID | ':' | ',' | '?' | ';' | '.' | '/' | '\\' | '!' | '@' | '\"' | '\'' | '*')* ;

//Terminal rule à faire
Path :
ID (':')? 
(
	(
		(('\\') | ('\\\\') | ('/')) 
		ID
	)?
)* 

(('\\') | ('\\\\') | ('/'));

Value :
ID | INT | STRING;

AnnotationType :
'override' | 'singleton' | 'LDFlags' | 'CFlags' | ID;

AttributeType :
'STRUCT' | 'UNION' | 'ENUM' | ID;

enum Contingency : 
optional | mandatory;

enum Role :
provides | requires;
